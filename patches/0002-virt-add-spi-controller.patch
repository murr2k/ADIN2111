From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Murray Kopit <murr2k@gmail.com>
Date: Wed, 20 Aug 2025 00:00:00 +0000
Subject: [PATCH] hw/arm/virt: Add PL022 SPI controller with ADIN2111 device

Add PL022 SPI controller to the virt machine and wire the ADIN2111
Ethernet switch/PHY device to the SPI bus for testing purposes.

The SPI controller is mapped at 0x09060000 with IRQ 10 and includes
device tree support. The ADIN2111 device is pre-attached to the SPI
bus as chip select 0, providing dual Ethernet ports for networking
tests in QEMU virt machines.

Signed-off-by: Murray Kopit <murr2k@gmail.com>
---
 hw/arm/virt.c         | 57 +++++++++++++++++++++++++++++++++++++++++++
 include/hw/arm/virt.h |  1 +
 2 files changed, 58 insertions(+)

diff --git a/hw/arm/virt.c b/hw/arm/virt.c
index 1234567890..abcdef1234 100644
--- a/hw/arm/virt.c
+++ b/hw/arm/virt.c
@@ -85,6 +85,7 @@
 #include "hw/char/pl011.h"
 #include "qemu/guest-random.h"
+#include "hw/ssi/pl022.h"
+#include "hw/net/adin2111.h"
 
 static GlobalProperty arm_virt_compat[] = {
     { TYPE_VIRTIO_IOMMU_PCI, "aw-bits", "48" },
@@ -168,6 +169,7 @@ static const MemMapEntry base_memmap[] = {
     [VIRT_RTC] =                { 0x09010000, 0x00001000 },
     [VIRT_FW_CFG] =             { 0x09020000, 0x00000018 },
     [VIRT_GPIO] =               { 0x09030000, 0x00001000 },
+    [VIRT_SPI] =                { 0x09060000, 0x00001000 },
     [VIRT_SECURE_UART] =        { 0x09040000, 0x00001000 },
     [VIRT_SMMU] =               { 0x09050000, 0x00020000 },
     [VIRT_PCDIMM_ACPI] =        { 0x09070000, MEMORY_HOTPLUG_IO_LEN },
@@ -217,6 +219,7 @@ static const int a15irqmap[] = {
     [VIRT_PCIE] = 3, /* ... to 6 */
     [VIRT_GPIO] = 7,
     [VIRT_SECURE_UART] = 8,
+    [VIRT_SPI] = 10,
     [VIRT_ACPI_GED] = 9,
     [VIRT_MMIO] = 16, /* ...to 16 + NUM_VIRTIO_TRANSPORTS - 1 */
     [VIRT_GIC_V2M] = 48, /* ...to 48 + NUM_GICV2M_SPIS - 1 */
@@ -960,6 +963,58 @@ static void create_rtc(const VirtMachineState *vms)
     g_free(nodename);
 }
 
+static void create_spi(const VirtMachineState *vms)
+{
+    char *nodename;
+    hwaddr base = vms->memmap[VIRT_SPI].base;
+    hwaddr size = vms->memmap[VIRT_SPI].size;
+    int irq = vms->irqmap[VIRT_SPI];
+    const char compat[] = "arm,pl022\0arm,primecell";
+    const char clocknames[] = "sspclk\0apb_pclk";
+    MachineState *ms = MACHINE(vms);
+    DeviceState *pl022_dev;
+    DeviceState *adin2111_dev;
+    SSIBus *spi_bus;
+    SysBusDevice *s;
+
+    /* Create PL022 SPI controller */
+    pl022_dev = qdev_new(TYPE_PL022);
+    s = SYS_BUS_DEVICE(pl022_dev);
+    sysbus_realize_and_unref(s, &error_fatal);
+    memory_region_add_subregion(get_system_memory(), base,
+                                sysbus_mmio_get_region(s, 0));
+    sysbus_connect_irq(s, 0, qdev_get_gpio_in(vms->gic, irq));
+
+    /* Get the SPI bus from PL022 */
+    spi_bus = (SSIBus *)qdev_get_child_bus(pl022_dev, "ssi");
+
+    /* Create and attach ADIN2111 device to SPI bus */
+    adin2111_dev = qdev_new(TYPE_ADIN2111);
+    qdev_prop_set_netdev(adin2111_dev, "netdev0", nd_table[0].netdev);
+    qdev_prop_set_netdev(adin2111_dev, "netdev1", nd_table[1].netdev);
+    qdev_realize_and_unref(adin2111_dev, BUS(spi_bus), &error_fatal);
+
+    /* Create device tree node for SPI controller */
+    nodename = g_strdup_printf("/pl022@%" PRIx64, base);
+    qemu_fdt_add_subnode(ms->fdt, nodename);
+    qemu_fdt_setprop(ms->fdt, nodename, "compatible",
+                     compat, sizeof(compat));
+    qemu_fdt_setprop_sized_cells(ms->fdt, nodename, "reg",
+                                 2, base, 2, size);
+    qemu_fdt_setprop_cells(ms->fdt, nodename, "interrupts",
+                           GIC_FDT_IRQ_TYPE_SPI, irq,
+                           GIC_FDT_IRQ_FLAGS_LEVEL_HI);
+    qemu_fdt_setprop_cells(ms->fdt, nodename, "clocks",
+                           vms->clock_phandle, vms->clock_phandle);
+    qemu_fdt_setprop(ms->fdt, nodename, "clock-names",
+                     clocknames, sizeof(clocknames));
+    qemu_fdt_setprop_cell(ms->fdt, nodename, "#address-cells", 1);
+    qemu_fdt_setprop_cell(ms->fdt, nodename, "#size-cells", 0);
+    qemu_fdt_setprop_cell(ms->fdt, nodename, "num-cs", 1);
+
+    g_free(nodename);
+}
+
 static void create_gpio_keys(char *fdt, DeviceState *pl061_dev,
                              uint32_t phandle)
 {
@@ -2304,6 +2359,8 @@ static void machvirt_init(MachineState *machine)
 
     create_rtc(vms);
 
+    create_spi(vms);
+
     create_pcie(vms);
 
     if (has_ged && aarch64 && firmware_loaded && virt_is_acpi_enabled(vms)) {
diff --git a/include/hw/arm/virt.h b/include/hw/arm/virt.h
index 1234567890..abcdef1234 100644
--- a/include/hw/arm/virt.h
+++ b/include/hw/arm/virt.h
@@ -70,6 +70,7 @@ enum {
     VIRT_PLATFORM_BUS,
     VIRT_GPIO,
     VIRT_SECURE_UART,
+    VIRT_SPI,
     VIRT_SECURE_MEM,
     VIRT_SECURE_GPIO,
     VIRT_PCDIMM_ACPI,
-- 
2.39.0