Custom analysis for adin2111.c
===============================

Checking for missing error handling...
31:	struct adin2111_priv *priv = container_of(work, struct adin2111_priv, irq_work);
260:	priv->pdata.switch_mode = of_property_read_bool(np, "adi,switch-mode");
261:	priv->pdata.cut_through = of_property_read_bool(np, "adi,cut-through");
262:	priv->pdata.tx_fcs_validation = of_property_read_bool(np, "adi,tx-fcs-validation");
263:	priv->pdata.crc_append = of_property_read_bool(np, "adi,crc-append");
266:	priv->pdata.port1_enabled = !of_property_read_bool(np, "adi,port1-disabled");
267:	priv->pdata.port2_enabled = !of_property_read_bool(np, "adi,port2-disabled");
312:	priv = devm_kzalloc(&spi->dev, sizeof(*priv), GFP_KERNEL);
331:	priv->reset_gpio = devm_gpiod_get_optional(&spi->dev, "reset", GPIOD_OUT_LOW);
341:	priv->regmap = adin2111_init_regmap(spi);
378:				netdev = adin2111_create_netdev(priv, i);
384:				struct adin2111_port *port = netdev_priv(netdev);
403:		netdev = adin2111_create_netdev(priv, 0);
459:	struct adin2111_priv *priv = spi_get_drvdata(spi);

Checking for potential memory leaks...
312:	priv = devm_kzalloc(&spi->dev, sizeof(*priv), GFP_KERNEL);
393:					free_netdev(netdev);
414:			free_netdev(netdev);
445:				free_netdev(priv->ports[i].netdev);
450:		free_netdev(priv->netdev);
478:				free_netdev(priv->ports[i].netdev);
483:		free_netdev(priv->netdev);

Checking for hardcoded values...
3: * ADIN2111 Dual Port Industrial Ethernet Switch/PHY Driver
5: * Copyright 2024 Analog Devices Inc.
22:#include "adin2111.h"
23:#include "adin2111_regs.h"
26:extern struct regmap *adin2111_init_regmap(struct spi_device *spi);
27:extern struct net_device *adin2111_create_netdev(struct adin2111_priv *priv, int port_num);
29:static void adin2111_work_handler(struct work_struct *work)
31:	struct adin2111_priv *priv = container_of(work, struct adin2111_priv, irq_work);
38:	ret = adin2111_read_reg(priv, ADIN2111_STATUS0, &status0);
42:	ret = adin2111_read_reg(priv, ADIN2111_STATUS1, &status1);
47:	if (status0 & ADIN2111_STATUS0_PHYINT) {
53:	if (priv->mode == ADIN2111_MODE_SWITCH) {
54:		if (status1 & ADIN2111_STATUS1_P1_RX_RDY) {
58:		if (status1 & ADIN2111_STATUS1_P2_RX_RDY) {
65:	if (status1 & ADIN2111_STATUS1_SPI_ERR) {
69:	if (status0 & ADIN2111_STATUS0_TXPE) {
73:	if (status0 & ADIN2111_STATUS0_RXEVM) {
78:	adin2111_write_reg(priv, ADIN2111_STATUS0, status0);
79:	adin2111_write_reg(priv, ADIN2111_STATUS1, status1);
85:irqreturn_t adin2111_irq_handler(int irq, void *dev_id)
87:	struct adin2111_priv *priv = dev_id;
91:		pr_err("adin2111: Invalid device context in IRQ handler\n");
99:int adin2111_hw_reset(struct adin2111_priv *priv)
105:		msleep(100);
111:int adin2111_soft_reset(struct adin2111_priv *priv)
117:	ret = adin2111_write_reg(priv, ADIN2111_RESET, ADIN2111_RESET_SWRESET);
122:	timeout = jiffies + msecs_to_jiffies(ADIN2111_RESET_TIMEOUT_MS);
124:		ret = adin2111_read_reg(priv, ADIN2111_RESET, &val);
128:		if (!(val & ADIN2111_RESET_SWRESET))
131:		usleep_range(100, 200);
137:static int adin2111_configure_switch_mode(struct adin2111_priv *priv)
143:	ret = adin2111_read_reg(priv, ADIN2111_CONFIG2, &config2);
149:		config2 |= ADIN2111_CONFIG2_PORT_CUT_THRU_EN;
151:		config2 &= ~ADIN2111_CONFIG2_PORT_CUT_THRU_EN;
155:		config2 |= ADIN2111_CONFIG2_CRC_APPEND;
157:		config2 &= ~ADIN2111_CONFIG2_CRC_APPEND;
159:	ret = adin2111_write_reg(priv, ADIN2111_CONFIG2, config2);
168:		port_func |= ADIN2111_PORT_FUNCT_BC_DIS_P1 |
169:			     ADIN2111_PORT_FUNCT_MC_DIS_P1;
173:		port_func |= ADIN2111_PORT_FUNCT_BC_DIS_P2 |
174:			     ADIN2111_PORT_FUNCT_MC_DIS_P2;
177:	ret = adin2111_write_reg(priv, ADIN2111_PORT_FUNCT, port_func);
187:int adin2111_hw_init(struct adin2111_priv *priv)
193:	adin2111_hw_reset(priv);
196:	ret = adin2111_soft_reset(priv);
203:	config0 = ADIN2111_CONFIG0_SYNC;
206:		config0 |= ADIN2111_CONFIG0_TXFCSVE;
208:	config0 |= ADIN2111_CONFIG0_TXCTE | ADIN2111_CONFIG0_RXCTE;
210:	ret = adin2111_write_reg(priv, ADIN2111_CONFIG0, config0);
216:		ret = adin2111_configure_switch_mode(priv);
222:	priv->irq_mask = ADIN2111_STATUS1_RX_RDY;
224:		priv->irq_mask |= ADIN2111_STATUS1_P1_RX_RDY |
225:				  ADIN2111_STATUS1_P2_RX_RDY;
228:	ret = adin2111_write_reg(priv, ADIN2111_IMASK1, ~priv->irq_mask);
233:	ret = adin2111_write_reg(priv, ADIN2111_CLEAR0, 0xFFFF);
237:	ret = adin2111_write_reg(priv, ADIN2111_CLEAR1, 0xFFFFFFFF);
242:	ret = adin2111_write_reg(priv, ADIN2111_FIFO_CLR,
243:				 ADIN2111_FIFO_CLR_TX | ADIN2111_FIFO_CLR_RX);
251:static int adin2111_parse_dt(struct adin2111_priv *priv)
294:int adin2111_probe(struct spi_device *spi)
296:	struct adin2111_priv *priv;
302:		pr_err("adin2111: NULL SPI device in probe\n");
323:	INIT_WORK(&priv->irq_work, adin2111_work_handler);
326:	ret = adin2111_parse_dt(priv);
341:	priv->regmap = adin2111_init_regmap(spi);
354:	ret = adin2111_hw_init(priv);
361:	ret = adin2111_phy_init(priv, 0);
368:		adin2111_soft_reset(priv);
375:		for (i = 0; i < ADIN2111_PORTS; i++) {
378:				netdev = adin2111_create_netdev(priv, i);
384:				struct adin2111_port *port = netdev_priv(netdev);
403:		netdev = adin2111_create_netdev(priv, 0);
424:						adin2111_irq_handler,
437:	dev_info(&spi->dev, "ADIN2111 driver probe completed successfully\n");
442:		for (i = 0; i < ADIN2111_PORTS; i++) {
453:	adin2111_phy_uninit(priv, 0);
457:void adin2111_remove(struct spi_device *spi)
459:	struct adin2111_priv *priv = spi_get_drvdata(spi);
468:	dev_info(&spi->dev, "Removing ADIN2111 driver\n");
475:		for (i = 0; i < ADIN2111_PORTS; i++) {
487:	adin2111_phy_uninit(priv, 0);
490:	adin2111_soft_reset(priv);
494:	{ .compatible = "adi,adin2111" },
497:MODULE_DEVICE_TABLE(of, adin2111_of_match);
500:	{ "adin2111", 0 },
503:MODULE_DEVICE_TABLE(spi, adin2111_spi_id);
505:static struct spi_driver adin2111_driver = {
507:		.name = ADIN2111_DRV_NAME,
508:		.of_match_table = adin2111_of_match,
510:	.probe = adin2111_probe,
511:	.remove = adin2111_remove,
512:	.id_table = adin2111_spi_id,
515:module_spi_driver(adin2111_driver);
517:MODULE_DESCRIPTION("ADIN2111 Dual Port Industrial Ethernet Switch/PHY Driver");
520:MODULE_VERSION(ADIN2111_DRV_VERSION);

Checking for missing __iomem annotations...
85:irqreturn_t adin2111_irq_handler(int irq, void *dev_id)
