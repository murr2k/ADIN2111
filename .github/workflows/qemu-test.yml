name: QEMU Hardware Testing

on:
  push:
    branches: [ main ]
    paths:
      - 'drivers/**'
      - 'qemu/**'
      - 'docker/**'
      - '.github/workflows/qemu-test.yml'
  pull_request:
    paths:
      - 'drivers/**'
      - 'qemu/**'
  workflow_dispatch:
    inputs:
      test_suite:
        description: 'Test suite to run'
        required: false
        default: 'all'
        type: choice
        options:
          - all
          - functional
          - performance
          - stress

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository_owner }}/qemu-adin2111

jobs:
  build-qemu-container:
    name: Build QEMU Container
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      image-tag: ${{ fromJSON(steps.meta.outputs.json).tags[0] }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: docker/qemu-adin2111.dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: |
            type=gha
            type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache
          cache-to: |
            type=gha,mode=max
            type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache,mode=max
          build-args: |
            JOBS=4
            BUILDKIT_INLINE_CACHE=1

  test-driver-qemu:
    name: Test Driver in QEMU
    needs: build-qemu-container
    runs-on: ubuntu-latest
    container:
      image: ${{ needs.build-qemu-container.outputs.image-tag }}
      options: --cap-add NET_ADMIN --cap-add SYS_ADMIN --device /dev/kvm
    
    strategy:
      fail-fast: false
      matrix:
        kernel: [6.6, 6.8]
        arch: [arm, arm64]
        test_suite: [functional, performance]
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Cache Kernel Build
        id: kernel-cache
        uses: actions/cache@v4
        with:
          path: |
            ~/kernel-cache/linux-${{ matrix.kernel }}
            ~/kernel-cache/linux-${{ matrix.kernel }}.tar.xz
          key: kernel-${{ matrix.kernel }}-${{ matrix.arch }}-${{ hashFiles('drivers/**/*.c', 'drivers/**/*.h') }}
          restore-keys: |
            kernel-${{ matrix.kernel }}-${{ matrix.arch }}-
            kernel-${{ matrix.kernel }}-
      
      - name: Cache Build Tools
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/ccache
            ~/tools-cache
          key: build-tools-${{ runner.os }}-${{ hashFiles('docker/**') }}
          restore-keys: |
            build-tools-${{ runner.os }}-
      
      - name: Setup Kernel Build
        shell: bash
        run: |
          echo "Setting up kernel ${{ matrix.kernel }} for ${{ matrix.arch }}"
          
          # Use ccache if available
          if command -v ccache > /dev/null 2>&1; then
            export CC="ccache gcc"
            export CXX="ccache g++"
            ccache -s
          fi
          
          # Check if kernel is cached
          KERNEL_CACHE_DIR="$HOME/kernel-cache"
          mkdir -p "$KERNEL_CACHE_DIR"
          
          if [ -d "$KERNEL_CACHE_DIR/linux-${{ matrix.kernel }}" ] && [ "${{ steps.kernel-cache.outputs.cache-hit }}" == "true" ]; then
            echo "Using cached kernel build"
            cp -r "$KERNEL_CACHE_DIR/linux-${{ matrix.kernel }}" .
            cd linux-${{ matrix.kernel }}
          else
            echo "Building kernel from source"
            
            # Kernel version checksums (update these for new kernel versions)
            declare -A KERNEL_SHA256
            KERNEL_SHA256["6.6"]="d926a06c63dd8ac7df3f86ee1ffc2ce2a3b81a2d168484e76b5b389aba8e56d0"
            KERNEL_SHA256["6.8"]="c969dea4e8bb6be991bbf7c010ba0e0a5643a3a8d8fb0a2aaa053406f1e965f3"
            
            # Check if tarball is cached
            if [ -f "$KERNEL_CACHE_DIR/linux-${{ matrix.kernel }}.tar.xz" ]; then
              echo "Using cached kernel tarball"
              cp "$KERNEL_CACHE_DIR/linux-${{ matrix.kernel }}.tar.xz" .
            else
              # Download kernel source with checksum verification
              KERNEL_URL="https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-${{ matrix.kernel }}.tar.xz"
              wget -q "$KERNEL_URL" -O linux-${{ matrix.kernel }}.tar.xz
              
              # Verify checksum
              EXPECTED_SHA="${KERNEL_SHA256[${{ matrix.kernel }}]}"
              if [ -n "$EXPECTED_SHA" ]; then
                echo "$EXPECTED_SHA  linux-${{ matrix.kernel }}.tar.xz" | sha256sum -c - || {
                  echo "ERROR: Kernel checksum verification failed for version ${{ matrix.kernel }}!"
                  echo "This could indicate a compromised download."
                  exit 1
                }
              else
                echo "WARNING: No checksum available for kernel ${{ matrix.kernel }}, proceeding without verification"
              fi
              
              # Cache the tarball
              cp linux-${{ matrix.kernel }}.tar.xz "$KERNEL_CACHE_DIR/"
            fi
            
            tar xf linux-${{ matrix.kernel }}.tar.xz
            cd linux-${{ matrix.kernel }}
          fi
          
          # Configure kernel with ADIN2111 driver
          if [ "${{ matrix.arch }}" = "arm" ]; then
            export ARCH=arm
            export CROSS_COMPILE=arm-linux-gnueabihf-
            make vexpress_defconfig
          else
            export ARCH=arm64
            export CROSS_COMPILE=aarch64-linux-gnu-
            make defconfig
          fi
          
          # Enable ADIN2111 driver
          ./scripts/config --enable CONFIG_ADIN2111
          ./scripts/config --enable CONFIG_SPI
          ./scripts/config --enable CONFIG_SPI_PL022
          ./scripts/config --enable CONFIG_NET
          ./scripts/config --enable CONFIG_ETHERNET
          
          # Copy our driver
          cp -r $GITHUB_WORKSPACE/drivers/net/ethernet/adi drivers/net/ethernet/
          
          # Build kernel with parallel jobs
          make -j$(nproc) Image modules
          
          # Cache the built kernel
          if [ "${{ steps.kernel-cache.outputs.cache-hit }}" != "true" ]; then
            echo "Caching built kernel..."
            cp -r . "$KERNEL_CACHE_DIR/linux-${{ matrix.kernel }}"
          fi
      
      - name: Cache Initramfs Components
        uses: actions/cache@v4
        with:
          path: |
            ~/initramfs-cache/busybox
            ~/initramfs-cache/initramfs-base.cpio.gz
          key: initramfs-${{ runner.os }}-${{ hashFiles('tests/qemu/**/*.sh') }}
          restore-keys: |
            initramfs-${{ runner.os }}-
      
      - name: Create Test Initramfs
        shell: bash
        run: |
          # Ensure cpio is installed (fallback if container doesn't have it)
          if ! command -v cpio > /dev/null 2>&1; then
            echo "cpio not found, installing..."
            apt-get update && apt-get install -y cpio gzip || true
          fi
          
          # Create minimal initramfs with test scripts
          INITRAMFS_CACHE="$HOME/initramfs-cache"
          mkdir -p "$INITRAMFS_CACHE"
          mkdir -p initramfs/{bin,sbin,etc,proc,sys,dev,tests}
          
          # Check for cached busybox
          if [ -f "$INITRAMFS_CACHE/busybox" ]; then
            echo "Using cached busybox"
            cp "$INITRAMFS_CACHE/busybox" busybox
          else
            # Download busybox with SHA256 verification
            BUSYBOX_URL="https://busybox.net/downloads/binaries/1.35.0-x86_64-linux-musl/busybox"
            BUSYBOX_SHA256="6e123e7f3202a8c1e9b1f94d8941580a25135382b99e8d3e34fb858bba311348"
            
            wget -q "$BUSYBOX_URL" -O busybox
            echo "$BUSYBOX_SHA256  busybox" | sha256sum -c - || {
              echo "ERROR: Busybox checksum verification failed!"
              echo "This could indicate a compromised download or supply chain attack."
              exit 1
            }
            
            # Cache busybox
            cp busybox "$INITRAMFS_CACHE/"
          fi
          
          chmod +x busybox
          cp busybox initramfs/bin/
          
          # Create init script
          cat > initramfs/init << 'EOF'
          #!/bin/busybox sh
          /bin/busybox --install -s
          
          # Mount essential filesystems
          mount -t proc none /proc
          mount -t sysfs none /sys
          mount -t devtmpfs none /dev
          
          # Load ADIN2111 driver
          modprobe adin2111
          
          # Run tests
          for test in /tests/*.sh; do
            echo "Running: $test"
            sh $test
          done
          
          # Signal completion
          poweroff -f
          EOF
          chmod +x initramfs/init
          
          # Copy test scripts
          cp tests/qemu/${{ matrix.test_suite }}/*.sh initramfs/tests/
          
          # Create initramfs archive
          cd initramfs
          find . | cpio -o -H newc | gzip > ../initramfs.cpio.gz
          cd ..
      
      - name: Run QEMU Tests
        timeout-minutes: 10
        shell: bash
        run: |
          # Copy SPI setup script
          cp qemu/test-scripts/setup-spi-device.sh .
          chmod +x setup-spi-device.sh
          
          # Determine kernel image path
          KERNEL_IMAGE=""
          if [ "${{ matrix.arch }}" = "arm" ]; then
            KERNEL_IMAGE="linux-${{ matrix.kernel }}/arch/arm/boot/zImage"
            QEMU_CMD="qemu-system-arm -M vexpress-a9 -m 512 -smp 2"
          else
            KERNEL_IMAGE="linux-${{ matrix.kernel }}/arch/arm64/boot/Image"
            QEMU_CMD="qemu-system-aarch64 -M virt -cpu cortex-a57 -m 1024 -smp 2"
          fi
          
          # Create device tree for SPI controller (ARM64 virt only)
          if [ "${{ matrix.arch }}" = "arm64" ]; then
            cat > spi-adin2111.dts << 'EOF'
          /dts-v1/;
          
          / {
            compatible = "linux,dummy-virt";
            
            spi@10040000 {
              compatible = "arm,pl022", "arm,primecell";
              reg = <0x0 0x10040000 0x0 0x1000>;
              interrupts = <0 11 4>;
              clocks = <&apb_pclk>, <&apb_pclk>;
              clock-names = "sspclk", "apb_pclk";
              #address-cells = <1>;
              #size-cells = <0>;
              status = "okay";
              
              adin2111@0 {
                compatible = "adi,adin2111";
                reg = <0>;
                spi-max-frequency = <25000000>;
                spi-cpha;
                interrupts = <0 12 4>;
                adi,switch-mode;
              };
            };
            
            apb_pclk: apb-pclk {
              compatible = "fixed-clock";
              #clock-cells = <0>;
              clock-frequency = <24000000>;
            };
          };
          EOF
          fi
          
          # Run QEMU with proper SPI setup
          # Note: Device tree modifications would need QEMU patches for full support
          # For now, we test module loading and basic functionality
          echo "Starting QEMU with SPI controller setup..."
          timeout 300 $QEMU_CMD \
            -kernel $KERNEL_IMAGE \
            -initrd initramfs.cpio.gz \
            -append "console=ttyAMA0 root=/dev/ram0 rdinit=/init loglevel=7 adin2111.debug=1" \
            -nographic \
            -monitor none \
            -serial stdio \
            2>&1 | tee qemu-output.log
          
          # Check for successful driver load
          if grep -q "ADIN2111 driver probe completed successfully" qemu-output.log; then
            echo "Driver loaded successfully in QEMU"
          elif grep -q "ADIN2111 driver loaded" qemu-output.log; then
            echo "Driver module loaded"
          fi
          
          # Check for test failures
          if grep -q "FAIL:" qemu-output.log; then
            echo "Tests failed!"
            exit 1
          fi
          
          # Check for kernel panics or BUGs
          if grep -q -E "(BUG:|Kernel panic|Oops)" qemu-output.log; then
            echo "Kernel issue detected!"
            grep -A 10 -E "(BUG:|Kernel panic|Oops)" qemu-output.log
            exit 1
          fi
          
          echo "All tests passed!"
      
      - name: Parse Test Results
        if: always()
        shell: bash
        run: |
          # Extract test results from QEMU output
          grep -E "(PASS|FAIL|SKIP):" qemu-output.log > test-results.txt || true
          
          # Generate summary
          echo "## Test Results Summary" > summary.md
          echo "Kernel: ${{ matrix.kernel }}" >> summary.md
          echo "Architecture: ${{ matrix.arch }}" >> summary.md
          echo "Test Suite: ${{ matrix.test_suite }}" >> summary.md
          echo "" >> summary.md
          
          PASS=$(grep -c "PASS:" test-results.txt || echo 0)
          FAIL=$(grep -c "FAIL:" test-results.txt || echo 0)
          SKIP=$(grep -c "SKIP:" test-results.txt || echo 0)
          
          echo "- ✅ Passed: $PASS" >> summary.md
          echo "- ❌ Failed: $FAIL" >> summary.md
          echo "- ⏭️ Skipped: $SKIP" >> summary.md
          
          cat summary.md >> $GITHUB_STEP_SUMMARY
      
      - name: Upload Test Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: qemu-test-${{ matrix.kernel }}-${{ matrix.arch }}-${{ matrix.test_suite }}
          path: |
            qemu-output.log
            test-results.txt
            summary.md

  performance-analysis:
    name: Performance Analysis
    needs: test-driver-qemu
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Download Test Artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: qemu-test-*-performance
          merge-multiple: true
      
      - name: Analyze Performance
        shell: bash
        run: |
          echo "## Performance Analysis" > performance.md
          
          # Parse performance metrics from test outputs
          for log in qemu-output*.log; do
            echo "### $log" >> performance.md
            grep -E "Throughput:|Latency:|CPU:" $log >> performance.md || true
            echo "" >> performance.md
          done
          
          cat performance.md >> $GITHUB_STEP_SUMMARY
      
      - name: Update Performance Dashboard
        if: github.ref == 'refs/heads/main'
        shell: bash
        run: |
          # Store performance metrics for trend analysis
          mkdir -p .metrics
          date > .metrics/timestamp
          cp performance.md .metrics/
          
          # Would commit metrics here in real scenario

  summary:
    name: Test Summary
    needs: [test-driver-qemu, performance-analysis]
    if: always()
    runs-on: ubuntu-latest
    
    steps:
      - name: Create Summary
        shell: bash
        run: |
          echo "# QEMU Testing Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ needs.test-driver-qemu.result }}" == "success" ]; then
            echo "✅ All QEMU tests passed successfully!" >> $GITHUB_STEP_SUMMARY
          else
            echo "❌ Some QEMU tests failed. Check individual job results." >> $GITHUB_STEP_SUMMARY
          fi